import type { InferOutput } from 'valibot';
export declare const StashedRequestData: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"connect", undefined>;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-transaction", undefined>;
    readonly transaction: import("valibot").StringSchema<"`transaction` is required">;
    readonly address: import("valibot").StringSchema<"`address` is required">;
    readonly chain: import("valibot").StringSchema<"`chain` is required">;
    readonly session: import("valibot").StringSchema<"`session` is required">;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-and-execute-transaction", undefined>;
    readonly transaction: import("valibot").StringSchema<"`transaction` is required">;
    readonly address: import("valibot").StringSchema<"`address` is required">;
    readonly chain: import("valibot").StringSchema<"`chain` is required">;
    readonly session: import("valibot").StringSchema<"`session` is required">;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-personal-message", undefined>;
    readonly chain: import("valibot").OptionalSchema<import("valibot").StringSchema<"`chain` is required">, never>;
    readonly message: import("valibot").StringSchema<"`message` is required">;
    readonly address: import("valibot").StringSchema<"`address` is required">;
    readonly session: import("valibot").StringSchema<"`session` is required">;
}, undefined>], undefined>;
export type StashedRequestData = InferOutput<typeof StashedRequestData>;
export declare const StashedRequest: import("valibot").ObjectSchema<{
    readonly version: import("valibot").LiteralSchema<"v1", undefined>;
    readonly requestId: import("valibot").SchemaWithPipe<[import("valibot").StringSchema<"`requestId` is required">, import("valibot").UuidAction<string, undefined>]>;
    readonly appUrl: import("valibot").SchemaWithPipe<[import("valibot").StringSchema<undefined>, import("valibot").UrlAction<string, "`appUrl` must be a valid URL">]>;
    readonly appName: import("valibot").StringSchema<"`appName` is required">;
    readonly payload: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"connect", undefined>;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-transaction", undefined>;
        readonly transaction: import("valibot").StringSchema<"`transaction` is required">;
        readonly address: import("valibot").StringSchema<"`address` is required">;
        readonly chain: import("valibot").StringSchema<"`chain` is required">;
        readonly session: import("valibot").StringSchema<"`session` is required">;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-and-execute-transaction", undefined>;
        readonly transaction: import("valibot").StringSchema<"`transaction` is required">;
        readonly address: import("valibot").StringSchema<"`address` is required">;
        readonly chain: import("valibot").StringSchema<"`chain` is required">;
        readonly session: import("valibot").StringSchema<"`session` is required">;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-personal-message", undefined>;
        readonly chain: import("valibot").OptionalSchema<import("valibot").StringSchema<"`chain` is required">, never>;
        readonly message: import("valibot").StringSchema<"`message` is required">;
        readonly address: import("valibot").StringSchema<"`address` is required">;
        readonly session: import("valibot").StringSchema<"`session` is required">;
    }, undefined>], undefined>;
    readonly metadata: import("valibot").OptionalSchema<import("valibot").RecordSchema<import("valibot").StringSchema<undefined>, import("valibot").AnySchema, undefined>, never>;
}, undefined>;
export type StashedRequest = InferOutput<typeof StashedRequest>;
export declare const StashedResponseData: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"connect", undefined>;
    readonly accounts: import("valibot").ArraySchema<import("valibot").ObjectSchema<{
        readonly address: import("valibot").StringSchema<"`address` is required">;
        readonly publicKey: import("valibot").OptionalSchema<import("valibot").StringSchema<"`publicKey` must be a string">, never>;
    }, undefined>, undefined>;
    readonly session: import("valibot").StringSchema<"`session` is required">;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-transaction", undefined>;
    readonly bytes: import("valibot").StringSchema<undefined>;
    readonly signature: import("valibot").StringSchema<undefined>;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-and-execute-transaction", undefined>;
    readonly bytes: import("valibot").StringSchema<undefined>;
    readonly signature: import("valibot").StringSchema<undefined>;
    readonly digest: import("valibot").StringSchema<undefined>;
    readonly effects: import("valibot").OptionalSchema<import("valibot").StringSchema<undefined>, never>;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"sign-personal-message", undefined>;
    readonly bytes: import("valibot").StringSchema<undefined>;
    readonly signature: import("valibot").StringSchema<undefined>;
}, undefined>], undefined>;
export type StashedResponseData = InferOutput<typeof StashedResponseData>;
export declare const StashedResponsePayload: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"reject", undefined>;
    readonly reason: import("valibot").OptionalSchema<import("valibot").StringSchema<"`reason` must be a string">, never>;
}, undefined>, import("valibot").ObjectSchema<{
    readonly type: import("valibot").LiteralSchema<"resolve", undefined>;
    readonly data: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"connect", undefined>;
        readonly accounts: import("valibot").ArraySchema<import("valibot").ObjectSchema<{
            readonly address: import("valibot").StringSchema<"`address` is required">;
            readonly publicKey: import("valibot").OptionalSchema<import("valibot").StringSchema<"`publicKey` must be a string">, never>;
        }, undefined>, undefined>;
        readonly session: import("valibot").StringSchema<"`session` is required">;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-transaction", undefined>;
        readonly bytes: import("valibot").StringSchema<undefined>;
        readonly signature: import("valibot").StringSchema<undefined>;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-and-execute-transaction", undefined>;
        readonly bytes: import("valibot").StringSchema<undefined>;
        readonly signature: import("valibot").StringSchema<undefined>;
        readonly digest: import("valibot").StringSchema<undefined>;
        readonly effects: import("valibot").OptionalSchema<import("valibot").StringSchema<undefined>, never>;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"sign-personal-message", undefined>;
        readonly bytes: import("valibot").StringSchema<undefined>;
        readonly signature: import("valibot").StringSchema<undefined>;
    }, undefined>], undefined>;
}, undefined>], undefined>;
export type StashedResponsePayload = InferOutput<typeof StashedResponsePayload>;
export declare const StashedResponse: import("valibot").ObjectSchema<{
    readonly id: import("valibot").SchemaWithPipe<[import("valibot").StringSchema<undefined>, import("valibot").UuidAction<string, undefined>]>;
    readonly source: import("valibot").LiteralSchema<"stashed-channel", undefined>;
    readonly payload: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"reject", undefined>;
        readonly reason: import("valibot").OptionalSchema<import("valibot").StringSchema<"`reason` must be a string">, never>;
    }, undefined>, import("valibot").ObjectSchema<{
        readonly type: import("valibot").LiteralSchema<"resolve", undefined>;
        readonly data: import("valibot").VariantSchema<"type", [import("valibot").ObjectSchema<{
            readonly type: import("valibot").LiteralSchema<"connect", undefined>;
            readonly accounts: import("valibot").ArraySchema<import("valibot").ObjectSchema<{
                readonly address: import("valibot").StringSchema<"`address` is required">;
                readonly publicKey: import("valibot").OptionalSchema<import("valibot").StringSchema<"`publicKey` must be a string">, never>;
            }, undefined>, undefined>;
            readonly session: import("valibot").StringSchema<"`session` is required">;
        }, undefined>, import("valibot").ObjectSchema<{
            readonly type: import("valibot").LiteralSchema<"sign-transaction", undefined>;
            readonly bytes: import("valibot").StringSchema<undefined>;
            readonly signature: import("valibot").StringSchema<undefined>;
        }, undefined>, import("valibot").ObjectSchema<{
            readonly type: import("valibot").LiteralSchema<"sign-and-execute-transaction", undefined>;
            readonly bytes: import("valibot").StringSchema<undefined>;
            readonly signature: import("valibot").StringSchema<undefined>;
            readonly digest: import("valibot").StringSchema<undefined>;
            readonly effects: import("valibot").OptionalSchema<import("valibot").StringSchema<undefined>, never>;
        }, undefined>, import("valibot").ObjectSchema<{
            readonly type: import("valibot").LiteralSchema<"sign-personal-message", undefined>;
            readonly bytes: import("valibot").StringSchema<undefined>;
            readonly signature: import("valibot").StringSchema<undefined>;
        }, undefined>], undefined>;
    }, undefined>], undefined>;
    readonly version: import("valibot").LiteralSchema<"v1", undefined>;
}, undefined>;
export type StashedResponse = InferOutput<typeof StashedResponse>;
export type StashedRequestTypes = Record<string, any> & {
    [P in StashedRequestData as P['type']]: P;
};
export type StashedResponseTypes = {
    [P in StashedResponseData as P['type']]: P;
};
