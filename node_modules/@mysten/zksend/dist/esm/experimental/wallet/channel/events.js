import {
  any,
  array,
  literal,
  object,
  optional,
  pipe,
  record,
  string,
  url,
  uuid,
  variant
} from "valibot";
const StashedRequestData = variant("type", [
  object({
    type: literal("connect")
  }),
  object({
    type: literal("sign-transaction"),
    transaction: string("`transaction` is required"),
    address: string("`address` is required"),
    chain: string("`chain` is required"),
    session: string("`session` is required")
  }),
  object({
    type: literal("sign-and-execute-transaction"),
    transaction: string("`transaction` is required"),
    address: string("`address` is required"),
    chain: string("`chain` is required"),
    session: string("`session` is required")
  }),
  object({
    type: literal("sign-personal-message"),
    chain: optional(string("`chain` is required")),
    message: string("`message` is required"),
    address: string("`address` is required"),
    session: string("`session` is required")
  })
]);
const StashedRequest = object({
  version: literal("v1"),
  requestId: pipe(string("`requestId` is required"), uuid()),
  appUrl: pipe(string(), url("`appUrl` must be a valid URL")),
  appName: string("`appName` is required"),
  payload: StashedRequestData,
  metadata: optional(record(string(), any()))
});
const StashedResponseData = variant("type", [
  object({
    type: literal("connect"),
    accounts: array(
      object({
        address: string("`address` is required"),
        publicKey: optional(string("`publicKey` must be a string"))
      })
    ),
    session: string("`session` is required")
  }),
  object({
    type: literal("sign-transaction"),
    bytes: string(),
    signature: string()
  }),
  object({
    type: literal("sign-and-execute-transaction"),
    bytes: string(),
    signature: string(),
    digest: string(),
    effects: optional(string())
  }),
  object({
    type: literal("sign-personal-message"),
    bytes: string(),
    signature: string()
  })
]);
const StashedResponsePayload = variant("type", [
  object({
    type: literal("reject"),
    reason: optional(string("`reason` must be a string"))
  }),
  object({
    type: literal("resolve"),
    data: StashedResponseData
  })
]);
const StashedResponse = object({
  id: pipe(string(), uuid()),
  source: literal("stashed-channel"),
  payload: StashedResponsePayload,
  version: literal("v1")
});
export {
  StashedRequest,
  StashedRequestData,
  StashedResponse,
  StashedResponseData,
  StashedResponsePayload
};
//# sourceMappingURL=events.js.map
