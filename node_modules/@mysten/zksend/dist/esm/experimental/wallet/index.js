var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _id, _events, _accounts, _origin, _walletName, _icon, _name, _signTransactionBlock, _signTransaction, _signAndExecuteTransaction, _signPersonalMessage, _on, _StashedWallet_instances, setAccounts_fn, _connect, _disconnect;
import { Transaction } from "@mysten/sui/transactions";
import { fromBase64, toBase64 } from "@mysten/sui/utils";
import {
  getWallets,
  ReadonlyWalletAccount,
  SUI_CHAINS,
  SUI_MAINNET_CHAIN
} from "@mysten/wallet-standard";
import mitt from "mitt";
import { boolean, object, parse, string } from "valibot";
import { DEFAULT_STASHED_ORIGIN, StashedPopup } from "./channel/index.js";
const STASHED_SESSION_KEY = "stashed:session";
const STASHED_WALLET_NAME = "Stashed";
const getStashedSession = () => {
  const { accounts = [], token } = JSON.parse(localStorage.getItem(STASHED_SESSION_KEY) || "{}");
  return { accounts, token };
};
const SUI_WALLET_EXTENSION_ID = "com.mystenlabs.suiwallet";
const METADATA_API_URL = "http://localhost:3001/api/wallet/metadata";
const WalletMetadataSchema = object({
  id: string("Wallet ID is required"),
  walletName: string("Wallet name is required"),
  icon: string("Icon must be a valid wallet icon format"),
  enabled: boolean("Enabled is required")
});
class StashedWallet {
  constructor({
    name,
    origin,
    metadata
  }) {
    __privateAdd(this, _StashedWallet_instances);
    __privateAdd(this, _id);
    __privateAdd(this, _events);
    __privateAdd(this, _accounts);
    __privateAdd(this, _origin);
    __privateAdd(this, _walletName);
    __privateAdd(this, _icon);
    __privateAdd(this, _name);
    __privateAdd(this, _signTransactionBlock, async ({
      transactionBlock,
      account,
      chain
    }) => {
      transactionBlock.setSenderIfNotSet(account.address);
      const data = await transactionBlock.toJSON();
      const popup = new StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin)
      });
      const response = await popup.send({
        type: "sign-transaction",
        transaction: data,
        address: account.address,
        chain,
        session: getStashedSession().token
      });
      return {
        transactionBlockBytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signTransaction, async ({ transaction, account, chain }) => {
      const popup = new StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        chain
      });
      const tx = await transaction.toJSON();
      const response = await popup.send({
        type: "sign-transaction",
        transaction: tx,
        address: account.address,
        chain,
        session: getStashedSession().token
      });
      return {
        bytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signAndExecuteTransaction, async ({
      transaction,
      account,
      chain
    }) => {
      const popup = new StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        chain
      });
      const tx = Transaction.from(await transaction.toJSON());
      tx.setSenderIfNotSet(account.address);
      const data = await tx.toJSON();
      const response = await popup.send({
        type: "sign-and-execute-transaction",
        transaction: data,
        address: account.address,
        chain,
        session: getStashedSession().token
      });
      return {
        bytes: response.bytes,
        signature: response.signature,
        digest: response.digest,
        effects: response.effects || ""
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account }) => {
      const popup = new StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin)
      });
      const response = await popup.send({
        type: "sign-personal-message",
        message: toBase64(message),
        address: account.address,
        session: getStashedSession().token
      });
      return {
        bytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      if (input?.silent) {
        const { accounts } = getStashedSession();
        if (accounts.length) {
          __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this, accounts);
        }
        return { accounts: this.accounts };
      }
      const popup = new StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin)
      });
      const response = await popup.send({
        type: "connect"
      });
      if (!("accounts" in response)) {
        throw new Error("Unexpected response");
      }
      localStorage.setItem(
        STASHED_SESSION_KEY,
        JSON.stringify({ accounts: response.accounts, token: response.session })
      );
      __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this, response.accounts);
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      localStorage.removeItem(STASHED_SESSION_KEY);
      __privateMethod(this, _StashedWallet_instances, setAccounts_fn).call(this);
    });
    __privateSet(this, _id, metadata.id);
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, mitt());
    __privateSet(this, _origin, origin || DEFAULT_STASHED_ORIGIN);
    __privateSet(this, _name, name);
    __privateSet(this, _walletName, metadata.walletName);
    __privateSet(this, _icon, metadata.icon);
  }
  get name() {
    return __privateGet(this, _walletName);
  }
  get id() {
    return __privateGet(this, _id);
  }
  get icon() {
    return __privateGet(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return SUI_CHAINS;
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: __privateGet(this, _signTransactionBlock)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: __privateGet(this, _signTransaction)
      },
      "sui:signPersonalMessage": {
        version: "1.1.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      },
      "sui:signAndExecuteTransaction": {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet(this, _signAndExecuteTransaction)
      }
    };
  }
  removeAccount(address) {
    const { accounts, token } = getStashedSession();
    const filteredAccounts = accounts.filter((account) => account.address !== address);
    if (filteredAccounts.length !== accounts.length) {
      localStorage.setItem(
        STASHED_SESSION_KEY,
        JSON.stringify({
          accounts: filteredAccounts,
          token
        })
      );
    }
    __privateSet(this, _accounts, __privateGet(this, _accounts).filter((account) => account.address !== address));
    __privateGet(this, _events).emit("change", { accounts: this.accounts });
  }
}
_id = new WeakMap();
_events = new WeakMap();
_accounts = new WeakMap();
_origin = new WeakMap();
_walletName = new WeakMap();
_icon = new WeakMap();
_name = new WeakMap();
_signTransactionBlock = new WeakMap();
_signTransaction = new WeakMap();
_signAndExecuteTransaction = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_StashedWallet_instances = new WeakSet();
setAccounts_fn = function(accounts) {
  if (accounts && accounts.length) {
    __privateSet(this, _accounts, accounts.map((account) => {
      return new ReadonlyWalletAccount({
        address: account.address,
        chains: [SUI_MAINNET_CHAIN],
        features: ["sui:signTransactionBlock", "sui:signPersonalMessage"],
        publicKey: account.publicKey ? fromBase64(account.publicKey) : new Uint8Array()
      });
    }));
  } else {
    __privateSet(this, _accounts, []);
  }
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
async function fetchMetadata(metadataApiUrl) {
  const response = await fetch(metadataApiUrl);
  if (!response.ok) {
    throw new Error("Failed to fetch wallet metadata");
  }
  const data = await response.json();
  return parse(WalletMetadataSchema, data);
}
async function registerStashedWallet(name, {
  origin,
  metadataApiUrl = METADATA_API_URL
} = {}) {
  const wallets = getWallets();
  const extension = wallets.get().find((wallet) => wallet.id === SUI_WALLET_EXTENSION_ID);
  if (extension) {
    return;
  }
  let metadata;
  try {
    metadata = await fetchMetadata(metadataApiUrl);
  } catch (error) {
    console.error("Error fetching metadata", error);
  }
  if (!metadata?.enabled) {
    console.log("Stashed wallet is not currently enabled.");
    return;
  }
  const stashedWalletInstance = new StashedWallet({
    name,
    origin,
    metadata
  });
  const unregister = wallets.register(stashedWalletInstance);
  wallets.on("register", (wallet) => {
    if (wallet.id === SUI_WALLET_EXTENSION_ID) {
      unregister();
    }
  });
  return {
    wallet: stashedWalletInstance,
    unregister
  };
}
export {
  STASHED_WALLET_NAME,
  StashedWallet,
  registerStashedWallet
};
//# sourceMappingURL=index.js.map
